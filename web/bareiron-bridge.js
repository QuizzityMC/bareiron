/**
 * Bareiron WebSocket Bridge
 * 
 * This bridge connects the WebAssembly Minecraft server to WebSocket clients.
 * It handles the WebSocket server functionality that would normally be done
 * by the operating system's TCP stack.
 */

const BareironBridge = (function() {
  let module = null;
  let websocketServer = null;
  let connections = new Map();
  let nextConnectionId = 1;
  
  /**
   * Initialize the WebAssembly module and WebSocket server
   */
  async function init() {
    console.log('Loading Bareiron WebAssembly module...');
    
    // Check if the module files exist
    try {
      const response = await fetch('bareiron.js');
      if (!response.ok) {
        throw new Error('bareiron.js not found. Please build the WASM module first using build_wasm.sh');
      }
    } catch (error) {
      throw new Error('Failed to load bareiron module: ' + error.message);
    }
    
    // Load and initialize the Emscripten module
    return new Promise((resolve, reject) => {
      // Note: bareiron.js will be generated by Emscripten
      // For now, we'll provide a stub that explains the process
      
      console.log('Note: To build the WebAssembly module, run:');
      console.log('  ./build_wasm.sh');
      console.log('This requires the Emscripten SDK to be installed.');
      
      // Since we're in development, show helpful message
      const stub = {
        status: 'stub',
        message: 'WASM module not yet built. Run build_wasm.sh to create it.'
      };
      
      console.warn('Running in stub mode - actual server not available yet');
      reject(new Error('WebAssembly module not built. Please run build_wasm.sh first.'));
    });
  }
  
  /**
   * Initialize WebSocket server to accept connections
   */
  function initWebSocketServer(port) {
    // In a browser environment, we can't create a true WebSocket server
    // Instead, we need a signaling mechanism
    
    console.log(`WebSocket bridge initialized for port ${port}`);
    console.log('Note: Direct WebSocket server not possible in browser.');
    console.log('You will need to use a WebSocket-to-TCP proxy like:');
    console.log('  - ws-tcp-relay (npm package)');
    console.log('  - websockify');
    console.log('  - Custom proxy server');
    
    // We'll use a simple message-based connection system
    // This is a limitation of running in a browser
    websocketServer = {
      port: port,
      active: true
    };
  }
  
  /**
   * Handle incoming WebSocket connection
   */
  function handleConnection(websocket) {
    const connId = nextConnectionId++;
    connections.set(connId, {
      ws: websocket,
      buffer: new Uint8Array(0)
    });
    
    console.log(`New WebSocket connection: ${connId}`);
    
    // Set up WebSocket event handlers
    websocket.onmessage = (event) => {
      handleMessage(connId, event.data);
    };
    
    websocket.onclose = () => {
      handleDisconnect(connId);
    };
    
    websocket.onerror = (error) => {
      console.error(`WebSocket error on connection ${connId}:`, error);
    };
    
    // Notify WASM module of new connection
    if (module && module._wasm_add_client_connection) {
      module._wasm_add_client_connection(connId);
    }
  }
  
  /**
   * Handle incoming message from WebSocket
   */
  function handleMessage(connId, data) {
    const conn = connections.get(connId);
    if (!conn) return;
    
    // Convert data to Uint8Array if needed
    let bytes;
    if (data instanceof ArrayBuffer) {
      bytes = new Uint8Array(data);
    } else if (data instanceof Blob) {
      // Handle blob asynchronously
      data.arrayBuffer().then(buffer => {
        handleMessage(connId, buffer);
      });
      return;
    } else {
      console.warn('Unexpected data type:', typeof data);
      return;
    }
    
    // Append to connection buffer
    const newBuffer = new Uint8Array(conn.buffer.length + bytes.length);
    newBuffer.set(conn.buffer);
    newBuffer.set(bytes, conn.buffer.length);
    conn.buffer = newBuffer;
    
    // Process the data through WASM module
    // The module will read from the buffer via recv() calls
  }
  
  /**
   * Handle WebSocket disconnection
   */
  function handleDisconnect(connId) {
    console.log(`WebSocket disconnected: ${connId}`);
    connections.delete(connId);
    
    // Notify WASM module
    if (module && module._wasm_remove_client_connection) {
      module._wasm_remove_client_connection(connId);
    }
  }
  
  /**
   * Send data to a WebSocket connection
   */
  function sendToConnection(connId, data) {
    const conn = connections.get(connId);
    if (!conn || !conn.ws) {
      console.warn(`Cannot send to connection ${connId}: not found`);
      return false;
    }
    
    try {
      conn.ws.send(data);
      return true;
    } catch (error) {
      console.error(`Failed to send to connection ${connId}:`, error);
      return false;
    }
  }
  
  /**
   * Stop the server
   */
  function stop() {
    console.log('Stopping WebSocket bridge...');
    
    // Close all connections
    for (const [connId, conn] of connections) {
      if (conn.ws) {
        conn.ws.close();
      }
    }
    connections.clear();
    
    // Stop WebSocket server
    if (websocketServer) {
      websocketServer.active = false;
      websocketServer = null;
    }
    
    console.log('WebSocket bridge stopped');
  }
  
  // Public API
  return {
    init,
    stop,
    handleConnection,
    sendToConnection
  };
})();
